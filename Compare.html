<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>List::Compare</title>
<link rev="made" href="mailto:jimk@james-e-keenans-computer.local" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#version">VERSION</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#discussion__modes_and_methods">DISCUSSION:  Modes and Methods</a></li>
	<ul>

		<li><a href="#regular_case__compare_two_lists">Regular Case:  Compare Two Lists</a></li>
		<li><a href="#accelerated_case__when_user_only_wants_a_single_comparison">Accelerated Case:  When User Only Wants a Single Comparison</a></li>
		<li><a href="#multiple_case__compare_three_or_more_lists">Multiple Case:  Compare Three or More Lists</a></li>
		<li><a href="#multiple_accelerated_case__compare_three_or_more_lists">Multiple Accelerated Case:  Compare Three or More Lists </a></li>
		<li><a href="#passing_seenhashes_to_the_constructor_instead_of_arrays">Passing Seen-hashes to the Constructor Instead of Arrays</a></li>
	</ul>

	<li><a href="#discussion__principles">DISCUSSION:  Principles</a></li>
	<ul>

		<li><a href="#general_comments">General Comments</a></li>
		<li><a href="#list__compare_modes">List::Compare Modes</a></li>
		<li><a href="#miscellaneous_methods">Miscellaneous Methods</a></li>
		<li><a href="#list__compare__seenhash_discontinued_beginning_with_version_0_26">List::Compare::SeenHash Discontinued Beginning with Version 0.26</a></li>
		<li><a href="#a_nonobjectoriented_interface__list__compare__functional">A Non-Object-Oriented Interface:  List::Compare::Functional</a></li>
	</ul>

	<li><a href="#assumptions_and_qualifications">ASSUMPTIONS AND QUALIFICATIONS</a></li>
	<li><a href="#history__references_and_development">HISTORY, REFERENCES AND DEVELOPMENT</a></li>
	<ul>

		<li><a href="#the_code_itself">The Code Itself</a></li>
		<li><a href="#the_inspiration">The Inspiration</a></li>
		<li><a href="#if_you_like_list__compare__you_ll_love____">If You Like List::Compare, You'll Love ...</a></li>
	</ul>

	<li><a href="#author">AUTHOR</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>List::Compare - Compare elements of two or more lists</p>
<p>
</p>
<hr />
<h1><a name="version">VERSION</a></h1>
<p>This document refers to version 0.31 of List::Compare.  This version was
released August 15, 2004.</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p>The bare essentials:</p>
<pre>
    @Llist = qw(abel abel baker camera delta edward fargo golfer);
    @Rlist = qw(baker camera delta delta edward fargo golfer hilton);</pre>
<pre>
    $lc = List::Compare-&gt;new(\@Llist, \@Rlist);</pre>
<pre>
    @intersection = $lc-&gt;get_intersection;
    @union = $lc-&gt;get_union;</pre>
<p>... and so forth.</p>
<p>
</p>
<hr />
<h1><a name="discussion__modes_and_methods">DISCUSSION:  Modes and Methods</a></h1>
<p>
</p>
<h2><a name="regular_case__compare_two_lists">Regular Case:  Compare Two Lists</a></h2>
<ul>
<li><strong><a name="item_constructor">Constructor</a></strong><br />
</li>
Create a List::Compare object.  Put the two lists into arrays (named or 
anonymous) and pass references to the arrays to the constructor.
<pre>
    @Llist = qw(abel abel baker camera delta edward fargo golfer);
    @Rlist = qw(baker camera delta delta edward fargo golfer hilton);</pre>
<pre>
    $lc = List::Compare-&gt;new(\@Llist, \@Rlist);</pre>
<p>By default, List::Compare's methods return lists which are sorted using 
Perl's default <code>sort</code> mode:  ASCII-betical sorting.  Should you
not need to have these lists sorted, you may achieve a speed boost 
by constructing the List::Compare object with the unsorted option:</p>
<pre>
    $lc = List::Compare-&gt;new('-u', \@Llist, \@Rlist);</pre>
<p>or</p>
<pre>
    $lc = List::Compare-&gt;new('--unsorted', \@Llist, \@Rlist);</pre>
<p></p>
<li><strong><a name="item_alternative_constructor">Alternative Constructor</a></strong><br />
</li>
If you prefer a more explicit delineation of the types of arguments passed 
to a function, you may use this 'single hashref' kind of constructor to build a 
List::Compare object:
<pre>
    $lc = List::Compare-&gt;new( { lists =&gt; [\@Llist, \@Rlist] } );</pre>
<p>or</p>
<pre>
    $lc = List::Compare-&gt;new( {
        lists    =&gt; [\@Llist, \@Rlist],
        unsorted =&gt; 1,
    } );</pre>
<p></p>
<li></li>
Get those items which appear at least once in both lists (their intersection).
<pre>
    @intersection = $lc-&gt;get_intersection;</pre>
<p></p>
<li></li>
Get those items which appear at least once in either list (their union).
<pre>
    @union = $lc-&gt;get_union;</pre>
<p></p>
<li></li>
Get those items which appear (at least once) only in the first list.
<pre>
    @Lonly = $lc-&gt;get_unique;
    @Lonly = $lc-&gt;get_Lonly;    # alias</pre>
<p></p>
<li></li>
Get those items which appear (at least once) only in the second list.
<pre>
    @Ronly = $lc-&gt;get_complement;
    @Ronly = $lc-&gt;get_Ronly;            # alias</pre>
<p></p>
<li></li>
Get those items which appear at least once in either the first or the second 
list, but not both.
<pre>
    @LorRonly = $lc-&gt;get_symmetric_difference;
    @LorRonly = $lc-&gt;get_symdiff;       # alias
    @LorRonly = $lc-&gt;get_LorRonly;      # alias</pre>
<p></p>
<li></li>
Make a bag of all those items in both lists.  The bag differs from the 
union of the two lists in that it holds as many copies of individual 
elements as appear in the original lists.
<pre>
    @bag = $lc-&gt;get_bag;</pre>
<p></p>
<li></li>
An alternative approach to the above methods:  If you do not immediately 
require an array as the return value of the method call, but simply need 
a <em>reference</em> to an (anonymous) array, use one of the following 
parallel methods:
<pre>
    $intersection_ref = $lc-&gt;get_intersection_ref;
    $union_ref        = $lc-&gt;get_union_ref;
    $Lonly_ref        = $lc-&gt;get_unique_ref;
    $Lonly_ref        = $lc-&gt;get_Lonly_ref;                 # alias
    $Ronly_ref        = $lc-&gt;get_complement_ref;
    $Ronly_ref        = $lc-&gt;get_Ronly_ref;                 # alias
    $LorRonly_ref     = $lc-&gt;get_symmetric_difference_ref;
    $LorRonly_ref     = $lc-&gt;get_symdiff_ref;               # alias
    $LorRonly_ref     = $lc-&gt;get_LorRonly_ref;              # alias
    $bag_ref          = $lc-&gt;get_bag_ref;</pre>
<p></p>
<li></li>
Return a true value if the first argument passed to the constructor 
('L' for 'left') is a subset of the second argument passed to the 
constructor ('R' for 'right').
<pre>
    $LR = $lc-&gt;is_LsubsetR;</pre>
<p>Return a true value if R is a subset of L.</p>
<pre>
    $RL = $lc-&gt;is_RsubsetL;</pre>
<p></p>
<li></li>
Return a true value if the two lists passed to the constructor are 
equivalent, <em>i.e.</em> if every element in the left-hand list ('L') appears 
at least once in the right-hand list ('R') and <em>vice versa</em>.
<pre>
    $eqv = $lc-&gt;is_LequivalentR;
    $eqv = $lc-&gt;is_LeqvlntR;            # alias</pre>
<p></p>
<li></li>
Return a true value if the two lists passed to the constructor are 
disjoint, <em>i.e.</em> if the two lists have zero elements in common (or, what 
is the same thing, if their intersection is an empty set).
<pre>
    $disj = $lc-&gt;is_LdisjointR;</pre>
<p></p>
<li></li>
Pretty-print a chart showing whether one list is a subset of the other.
<pre>
    $lc-&gt;print_subset_chart;</pre>
<p></p>
<li></li>
Pretty-print a chart showing whether the two lists are equivalent (same 
elements found at least once in both).
<pre>
    $lc-&gt;print_equivalence_chart;</pre>
<p></p>
<li></li>
Determine in <em>which</em> (if any) of the lists passed to the constructor a given 
string can be found.  In list context, return a list of those indices in the 
constructor's argument list corresponding to lists holding the string being 
tested.
<pre>
    @memb_arr = $lc-&gt;is_member_which('abel');</pre>
<p>In the example above, <code>@memb_arr</code> will be:</p>
<pre>
    ( 0 )</pre>
<p>because <code>'abel'</code> is found only in <code>@Al</code> which holds position <code>0</code> in the 
list of arguments passed to <code>new()</code>.</p>
<p></p>
<li></li>
In scalar context, the return value is the number of lists passed to the 
constructor in which a given string is found.
<p></p>
<li></li>
As with other List::Compare methods which return a list, you may wish the 
above method returned a (scalar) reference to an array holding the list:
<pre>
    $memb_arr_ref = $lc-&gt;is_member_which_ref('baker');</pre>
<p>In the example above, <code>$memb_arr_ref</code> will be:</p>
<pre>
    [ 0, 1 ]</pre>
<p>because <code>'baker'</code> is found in <code>@Llist</code> and <code>@Rlist</code>, which hold positions 
<code>0</code> and <code>1</code>, respectively, in the list of arguments passed to <code>new()</code>.</p>
<p><strong>Note:</strong>  methods <code>is_member_which()</code> and <code>is_member_which_ref</code> test
only one string at a time and hence take only one argument.  To test more 
than one string at a time see the next method, <code>are_members_which()</code>.</p>
<p></p>
<li></li>
Determine in <em>which</em> (if any) of the lists passed to the constructor one or 
more given strings can be found.  The strings to be tested are placed in an 
array (named or anonymous); a reference to that array is passed to the method.
<pre>
    $memb_hash_ref = 
        $lc-&gt;are_members_which([ qw| abel baker fargo hilton zebra | ]);</pre>
<p><em>Note:</em>  In versions of List::Compare prior to 0.25 (April 2004), the 
strings to be tested could be passed as a flat list.  This is no longer 
possible; the argument must now be a reference to an array.</p>
<p>The return value is a reference to a hash of arrays.  The 
key for each element in this hash is the string being tested.  Each element's 
value is a reference to an anonymous array whose elements are those indices in 
the constructor's argument list corresponding to lists holding the strings 
being tested.  In the examples above, <code>$memb_hash_ref</code> will be:</p>
<pre>
    {
         abel     =&gt; [ 0    ],
         baker    =&gt; [ 0, 1 ],
         fargo    =&gt; [ 0, 1 ],
         hilton   =&gt; [    1 ],
         zebra    =&gt; [      ],
    };</pre>
<p><strong>Note:</strong>  <code>are_members_which()</code> can take more than one argument; 
<code>is_member_which()</code> and <code>is_member_which_ref()</code> each take only one argument.  
Unlike those two methods, <code>are_members_which()</code> returns a hash reference.</p>
<p></p>
<li></li>
Determine whether a given string can be found in <em>any</em> of the lists passed as 
arguments to the constructor.  Return 1 if a specified string can be found in 
any of the lists and 0 if not.
<pre>
    $found = $lc-&gt;is_member_any('abel');</pre>
<p>In the example above, <code>$found</code> will be <code>1</code> because <code>'abel'</code> is found in one 
or more of the lists passed as arguments to <code>new()</code>.</p>
<p></p>
<li></li>
Determine whether a specified string or strings can be found in <em>any</em> of the 
lists passed as arguments to the constructor.  The strings to be tested are 
placed in an array (named or anonymous); a reference to that array is passed to 
<code>are_members_any</code>.
<pre>
    $memb_hash_ref = $lc-&gt;are_members_any([ qw| abel baker fargo hilton zebra | ]);</pre>
<p><em>Note:</em>  In versions of List::Compare prior to 0.25 (April 2004), the 
strings to be tested could be passed as a flat list.  This is no longer 
possible; the argument must now be a reference to an array.</p>
<p>The return value is a reference to a hash where an element's key is the 
string being tested and the element's value is 1 if the string can be 
found in <em>any</em> of the lists and 0 if not.  In the examples above, 
<code>$memb_hash_ref</code> will be:</p>
<pre>
    {
         abel     =&gt; 1,
         baker    =&gt; 1,
         fargo    =&gt; 1,
         hilton   =&gt; 1,
         zebra    =&gt; 0,
    };</pre>
<p><code>zebra</code>'s value is <code>0</code> because <code>zebra</code> is not found in either of the lists 
passed as arguments to <code>new()</code>.</p>
<p></p>
<li></li>
Return current List::Compare version number.
<pre>
    $vers = $lc-&gt;get_version;</pre>
<p></p></ul>
<p>
</p>
<h2><a name="accelerated_case__when_user_only_wants_a_single_comparison">Accelerated Case:  When User Only Wants a Single Comparison</a></h2>
<ul>
<li><strong>Constructor</strong><br />
</li>
If you are certain that you will only want the results of a <em>single</em> 
comparison, computation may be accelerated by passing <code>'-a'</code> or 
<code>'--accelerated</code> as the first argument to the constructor.
<pre>
    @Llist = qw(abel abel baker camera delta edward fargo golfer);
    @Rlist = qw(baker camera delta delta edward fargo golfer hilton);</pre>
<pre>
    $lca = List::Compare-&gt;new('-a', \@Llist, \@Rlist);</pre>
<p>or</p>
<pre>
    $lca = List::Compare-&gt;new('--accelerated', \@Llist, \@Rlist);</pre>
<p>As with List::Compare's Regular case, should you not need to have 
a sorted list returned by an accelerated List::Compare method, you may 
achieve a speed boost by constructing the accelerated List::Compare object 
with the unsorted option:</p>
<pre>
    $lca = List::Compare-&gt;new('-u', '-a', \@Llist, \@Rlist);</pre>
<p>or</p>
<pre>
    $lca = List::Compare-&gt;new('--unsorted', '--accelerated', \@Llist, \@Rlist);</pre>
<p></p>
<li><strong>Alternative Constructor</strong><br />
</li>
You may use the 'single hashref' constructor format to build a List::Compare 
object calling for the Accelerated mode:
<pre>
    $lca = List::Compare-&gt;new( {
        lists    =&gt; [\@Llist, \@Rlist],
        accelerated =&gt; 1,
    } );</pre>
<p>or</p>
<pre>
    $lca = List::Compare-&gt;new( {
        lists    =&gt; [\@Llist, \@Rlist],
        accelerated =&gt; 1,
        unsorted =&gt; 1,
    } );</pre>
<p></p>
<li><strong><a name="item_methods">Methods</a></strong><br />
</li>
All the comparison methods available in the Regular case are available to 
you in the Accelerated case as well.
<pre>
    @intersection     = $lca-&gt;get_intersection;
    @union            = $lca-&gt;get_union;
    @Lonly            = $lca-&gt;get_unique;
    @Ronly            = $lca-&gt;get_complement;
    @LorRonly         = $lca-&gt;get_symmetric_difference;
    @bag              = $lca-&gt;get_bag;
    $intersection_ref = $lca-&gt;get_intersection_ref;
    $union_ref        = $lca-&gt;get_union_ref;
    $Lonly_ref        = $lca-&gt;get_unique_ref;
    $Ronly_ref        = $lca-&gt;get_complement_ref;
    $LorRonly_ref     = $lca-&gt;get_symmetric_difference_ref;
    $bag_ref          = $lca-&gt;get_bag_ref;
    $LR               = $lca-&gt;is_LsubsetR;
    $RL               = $lca-&gt;is_RsubsetL;
    $eqv              = $lca-&gt;is_LequivalentR;
    $disj             = $lca-&gt;is_LdisjointR;
                        $lca-&gt;print_subset_chart;
                        $lca-&gt;print_equivalence_chart;
    @memb_arr         = $lca-&gt;is_member_which('abel');
    $memb_arr_ref     = $lca-&gt;is_member_which_ref('baker');
    $memb_hash_ref    = $lca-&gt;are_members_which(
                            [ qw| abel baker fargo hilton zebra | ]);
    $found            = $lca-&gt;is_member_any('abel');
    $memb_hash_ref    = $lca-&gt;are_members_any(
                            [ qw| abel baker fargo hilton zebra | ]);
    $vers             = $lca-&gt;get_version;</pre>
<p>All the aliases for methods available in the Regular case are available to 
you in the Accelerated case as well.</p>
<p></p></ul>
<p>
</p>
<h2><a name="multiple_case__compare_three_or_more_lists">Multiple Case:  Compare Three or More Lists</a></h2>
<ul>
<li><strong>Constructor</strong><br />
</li>
Create a List::Compare object.  Put each list into an array and pass
references to the arrays to the constructor.
<pre>
    @Al     = qw(abel abel baker camera delta edward fargo golfer);
    @Bob    = qw(baker camera delta delta edward fargo golfer hilton);
    @Carmen = qw(fargo golfer hilton icon icon jerky kappa);
    @Don    = qw(fargo icon jerky);
    @Ed     = qw(fargo icon icon jerky);</pre>
<pre>
    $lcm = List::Compare-&gt;new(\@Al, \@Bob, \@Carmen, \@Don, \@Ed);</pre>
<p>As with List::Compare's Regular case, should you not need to have 
a sorted list returned by a List::Compare method, you may achieve a 
speed boost by constructing the object with the unsorted option:</p>
<pre>
    $lcm = List::Compare-&gt;new('-u', \@Al, \@Bob, \@Carmen, \@Don, \@Ed);</pre>
<p>or</p>
<pre>
    $lcm = List::Compare-&gt;new('--unsorted', \@Al, \@Bob, \@Carmen, \@Don, \@Ed);</pre>
<p></p>
<li><strong>Alternative Constructor</strong><br />
</li>
You may use the 'single hashref' constructor format to build a List::Compare 
object to process three or more lists at once:
<pre>
    $lcm = List::Compare-&gt;new( {
        lists    =&gt; [\@Al, \@Bob, \@Carmen, \@Don, \@Ed],
    } );</pre>
<p>or</p>
<pre>
    $lcm = List::Compare-&gt;new( {
        lists    =&gt; [\@Al, \@Bob, \@Carmen, \@Don, \@Ed],
        unsorted =&gt; 1,
    } );</pre>
<p></p>
<li><strong><a name="item_multiple_mode_methods_analogous_to_regular_and_acc">Multiple Mode Methods Analogous to Regular and Accelerated Mode Methods</a></strong><br />
</li>
Each List::Compare method available in the Regular and Accelerated cases 
has an analogue in the Multiple case.  However, the results produced 
usually require more careful specification.
<p><strong>Note:</strong>  Certain of the following methods available in List::Compare's 
Multiple mode take optional numerical arguments where those numbers 
represent the index position of a particular list in the list of arguments 
passed to the constructor.  To specify this index position correctly,</p>
<ul>
<li></li>
start the count at <code>0</code> (as is customary with Perl array indices); and
<p></p>
<li></li>
do <em>not</em> count any unsorted option (<code>'-u'</code> or <code>'--unsorted'</code>) preceding 
the array references in the constructor's own argument list.
<p></p></ul>
<p>Example:</p>
<pre>
    $lcmex = List::Compare-&gt;new('--unsorted', \@alpha, \@beta, \@gamma);</pre>
<p>For the purpose of supplying a numerical argument to a method which 
optionally takes such an argument, <code>'--unsorted'</code> is skipped, <code>@alpha</code> 
is <code>0</code>, <code>@beta</code> is <code>1</code>, and so forth.</p>
<ul>
<li></li>
Get those items found in <em>each</em> of the lists passed to the constructor 
(their intersection):
<pre>
    @intersection = $lcm-&gt;get_intersection;</pre>
<p></p>
<li></li>
Get those items found in <em>any</em> of the lists passed to the constructor 
(their union):
<pre>
    @union = $lcm-&gt;get_union;</pre>
<p></p>
<li></li>
To get those items which appear only in <em>one particular list,</em> provide 
<code>get_unique()</code> with that list's index position in the list of arguments 
passed to the constructor (not counting any <code>'-u'</code> or <code>'--unsorted'</code> 
option).
<p>Example:  <code>@Carmen</code> has index position <code>2</code> in the constructor's <code>@_</code>.  
To get elements unique to <code>@Carmen</code>:</p>
<pre>
    @Lonly = $lcm-&gt;get_unique(2);</pre>
<p>If no index position is passed to <code>get_unique()</code> it will default to 0 
and report items unique to the first list passed to the constructor.</p>
<p></p>
<li></li>
To get those items which appear in any list <em>other than one particular 
list,</em> provide <code>get_complement()</code> with that list's index position in 
the list of arguments passed to the constructor (not counting any 
<code>'-u'</code> or <code>'--unsorted'</code> option).
<p>Example:  <code>@Don</code> has index position <code>3</code> in the constructor's <code>@_</code>.  
To get elements not found in <code>@Don</code>:</p>
<pre>
    @Ronly = $lcm-&gt;get_complement(3);</pre>
<p>If no index position is passed to <code>get_complement()</code> it will default to 
0 and report items found in any list other than the first list passed 
to the constructor.</p>
<p></p>
<li></li>
Get those items each of which appears in <em>only one</em> of the lists 
passed to the constructor (their symmetric_difference);
<pre>
    @LorRonly = $lcm-&gt;get_symmetric_difference;</pre>
<p></p>
<li></li>
Make a bag of all items found in any list.  The bag differs from the 
lists' union in that it holds as many copies of individual elements 
as appear in the original lists.
<pre>
    @bag = $lcm-&gt;get_bag;</pre>
<p></p>
<li></li>
An alternative approach to the above methods:  If you do not immediately 
require an array as the return value of the method call, but simply need 
a <em>reference</em> to an array, use one of the following parallel methods:
<pre>
    $intersection_ref = $lcm-&gt;get_intersection_ref;
    $union_ref        = $lcm-&gt;get_union_ref;
    $Lonly_ref        = $lcm-&gt;get_unique_ref(2);
    $Ronly_ref        = $lcm-&gt;get_complement_ref(3);
    $LorRonly_ref     = $lcm-&gt;get_symmetric_difference_ref;
    $bag_ref          = $lcm-&gt;get_bag_ref;</pre>
<p></p>
<li></li>
To determine whether one particular list is a subset of another list 
passed to the constructor, provide <code>is_LsubsetR()</code> with the index 
position of the presumed subset (ignoring any unsorted option), followed 
by the index position of the presumed superset.
<p>Example:  To determine whether <code>@Ed</code> is a subset of <code>@Carmen</code>, call:</p>
<pre>
    $LR = $lcm-&gt;is_LsubsetR(4,2);</pre>
<p>A true value (<code>1</code>) is returned if the left-hand list is a subset of the 
right-hand list; a false value (<code>0</code>) is returned otherwise.</p>
<p>If no arguments are passed, <code>is_LsubsetR()</code> defaults to <code>(0,1)</code> and 
compares the first two lists passed to the constructor.</p>
<p></p>
<li></li>
To determine whether any two particular lists are equivalent to each 
other, provide <code>is_LequivalentR</code> with their index positions in the 
list of arguments passed to the constructor (ignoring any unsorted option).
<p>Example:  To determine whether <code>@Don</code> and <code>@Ed</code> are equivalent, call:</p>
<pre>
    $eqv = $lcm-&gt;is_LequivalentR(3,4);</pre>
<p>A true value (<code>1</code>) is returned if the lists are equivalent; a false value 
(<code>0</code>) otherwise.</p>
<p>If no arguments are passed, <code>is_LequivalentR</code> defaults to <code>(0,1)</code> and 
compares the first two lists passed to the constructor.</p>
<p></p>
<li></li>
To determine whether any two particular lists are disjoint from each other 
(<em>i.e.,</em> have no members in common), provide <code>is_LdisjointR</code> with their 
index positions in the list of arguments passed to the constructor 
(ignoring any unsorted option).
<p>Example:  To determine whether <code>@Don</code> and <code>@Ed</code> are disjoint, call:</p>
<pre>
    $disj = $lcm-&gt;is_LdisjointR(3,4);</pre>
<p>A true value (<code>1</code>) is returned if the lists are equivalent; a false value 
(<code>0</code>) otherwise.</p>
<p>If no arguments are passed, <code>is_LdisjointR</code> defaults to <code>(0,1)</code> and 
compares the first two lists passed to the constructor.</p>
<p></p>
<li></li>
Pretty-print a chart showing the subset relationships among the various 
source lists:
<pre>
    $lcm-&gt;print_subset_chart;</pre>
<p></p>
<li></li>
Pretty-print a chart showing the equivalence relationships among the 
various source lists:
<pre>
    $lcm-&gt;print_equivalence_chart;</pre>
<p></p>
<li></li>
Determine in <em>which</em> (if any) of the lists passed to the constructor a given 
string can be found.  In list context, return a list of those indices in the 
constructor's argument list (ignoring any unsorted option) corresponding to i
lists holding the string being tested.
<pre>
    @memb_arr = $lcm-&gt;is_member_which('abel');</pre>
<p>In the example above, <code>@memb_arr</code> will be:</p>
<pre>
    ( 0 )</pre>
<p>because <code>'abel'</code> is found only in <code>@Al</code> which holds position <code>0</code> in the 
list of arguments passed to <code>new()</code>.</p>
<p></p>
<li></li>
As with other List::Compare methods which return a list, you may wish the 
above method returned a (scalar) reference to an array holding the list:
<pre>
    $memb_arr_ref = $lcm-&gt;is_member_which_ref('jerky');</pre>
<p>In the example above, <code>$memb_arr_ref</code> will be:</p>
<pre>
    [ 3, 4 ]</pre>
<p>because <code>'jerky'</code> is found in <code>@Don</code> and <code>@Ed</code>, which hold positions 
<code>3</code> and <code>4</code>, respectively, in the list of arguments passed to <code>new()</code>.</p>
<p><strong>Note:</strong>  methods <code>is_member_which()</code> and <code>is_member_which_ref</code> test
only one string at a time and hence take only one argument.  To test more 
than one string at a time see the next method, <code>are_members_which()</code>.</p>
<p></p>
<li></li>
Determine in <code>which</code> (if any) of the lists passed to the constructor one or 
more given strings can be found.  The strings to be tested are placed in an 
anonymous array, a reference to which is passed to the method.
<pre>
    $memb_hash_ref = 
        $lcm-&gt;are_members_which([ qw| abel baker fargo hilton zebra | ]);</pre>
<p><em>Note:</em>  In versions of List::Compare prior to 0.25 (April 2004), the 
strings to be tested could be passed as a flat list.  This is no longer 
possible; the argument must now be a reference to an anonymous array.</p>
<p>The return value is a reference to a hash of arrays.  The 
key for each element in this hash is the string being tested.  Each element's 
value is a reference to an anonymous array whose elements are those indices in 
the constructor's argument list corresponding to lists holding the strings 
being tested.</p>
<p>In the two examples above, <code>$memb_hash_ref</code> will be:</p>
<pre>
    {
         abel     =&gt; [ 0             ],
         baker    =&gt; [ 0, 1          ],
         fargo    =&gt; [ 0, 1, 2, 3, 4 ],
         hilton   =&gt; [    1, 2       ],
         zebra    =&gt; [               ],
    };</pre>
<p><strong>Note:</strong>  <code>are_members_which()</code> can take more than one argument; 
<code>is_member_which()</code> and <code>is_member_which_ref()</code> each take only one argument.  
<code>are_members_which()</code> returns a hash reference; the other methods return 
either a list or a reference to an array holding that list, depending on 
context.</p>
<p></p>
<li></li>
Determine whether a given string can be found in <em>any</em> of the lists passed as 
arguments to the constructor.
<pre>
    $found = $lcm-&gt;is_member_any('abel');</pre>
<p>Return <code>1</code> if a specified string can be found in <em>any</em> of the lists 
and <code>0</code> if not.</p>
<p>In the example above, <code>$found</code> will be <code>1</code> because <code>'abel'</code> is found in one 
or more of the lists passed as arguments to <code>new()</code>.</p>
<p></p>
<li></li>
Determine whether a specified string or strings can be found in <em>any</em> of the 
lists passed as arguments to the constructor.  The strings to be tested are 
placed in an array (anonymous or named), a reference to which is passed to 
the method.
<pre>
    $memb_hash_ref = $lcm-&gt;are_members_any([ qw| abel baker fargo hilton zebra | ]);</pre>
<p><em>Note:</em>  In versions of List::Compare prior to 0.25 (April 2004), the 
strings to be tested could be passed as a flat list.  This is no longer 
possible; the argument must now be a reference to an anonymous array.</p>
<p>The return value is a reference to a hash where an element's key is the 
string being tested and the element's value is 1 if the string can be 
found in <code>any</code> of the lists and 0 if not.  
In the two examples above, <code>$memb_hash_ref</code> will be:</p>
<pre>
    {
         abel     =&gt; 1,
         baker    =&gt; 1,
         fargo    =&gt; 1,
         hilton   =&gt; 1,
         zebra    =&gt; 0,
    };</pre>
<p><code>zebra</code>'s value will be <code>0</code> because <code>zebra</code> is not found in any of the 
lists passed as arguments to <code>new()</code>.</p>
<p></p>
<li></li>
Return current List::Compare version number:
<pre>
    $vers = $lcm-&gt;get_version;</pre>
<p></p></ul>
<li><strong><a name="item_multiple_mode_methods_not_analogous_to_regular_and">Multiple Mode Methods Not Analogous to Regular and Accelerated Mode Methods</a></strong><br />
</li>
<ul>
<li></li>
Get those items found in <em>any</em> of the lists passed to the constructor which 
do <em>not</em> appear in <em>all</em> of the lists (<em>i.e.,</em> all items except those found 
in the intersection of the lists):
<pre>
    @nonintersection = $lcm-&gt;get_nonintersection;</pre>
<p></p>
<li></li>
Get those items which appear in more than one of the lists passed to the 
constructor (<em>i.e.,</em> all items except those found in their symmetric 
difference);
<pre>
    @shared = $lcm-&gt;get_shared;</pre>
<p></p>
<li></li>
If you only need a reference to an array as a return value rather than a 
full array, use the following alternative methods:
<pre>
    $nonintersection_ref = $lcm-&gt;get_nonintersection_ref;
    $shared_ref = $lcm-&gt;get_shared_ref;</pre>
<p></p>
<li></li>
Get a reference to an array of array references where each of the interior 
arrays holds the list of those items <em>unique</em> to the list passed to the 
constructor with the same index position.
<pre>
    $unique_all_ref = $lcm-&gt;get_unique_all();</pre>
<p>In the example above, <code>$unique_all_ref</code> will hold:</p>
<pre>
    [
        [ qw| abel | ],
        [ ],
        [ qw| jerky | ],
        [ ],
        [ ],
    ]</pre>
<p></p>
<li></li>
Get a reference to an array of array references where each of the interior 
arrays holds the list of those items in the <em>complement</em> to the list 
passed to the constructor with the same index position.
<pre>
    $complement_all_ref = $lcm-&gt;get_complement_all();</pre>
<p>In the example above, <code>$complement_all_ref</code> will hold:</p>
<pre>
    [
        [ qw| hilton icon jerky | ],
        [ qw| abel icon jerky | ],
        [ qw| abel baker camera delta edward | ],
        [ qw| abel baker camera delta edward jerky | ],
        [ qw| abel baker camera delta edward jerky | ],
    ]</pre>
<p></p></ul>
</ul>
<p>
</p>
<h2><a name="multiple_accelerated_case__compare_three_or_more_lists_but_request_only_a_single_comparison_among_the_lists">Multiple Accelerated Case:  Compare Three or More Lists 
but Request Only a Single Comparison among the Lists</a></h2>
<ul>
<li><strong>Constructor</strong><br />
</li>
If you are certain that you will only want the results of a single 
comparison among three or more lists, computation may be accelerated 
by passing <code>'-a'</code> or <code>'--accelerated</code> as the first argument to 
the constructor.
<pre>
    @Al     = qw(abel abel baker camera delta edward fargo golfer);
    @Bob    = qw(baker camera delta delta edward fargo golfer hilton);
    @Carmen = qw(fargo golfer hilton icon icon jerky kappa);
    @Don    = qw(fargo icon jerky);
    @Ed     = qw(fargo icon icon jerky);</pre>
<pre>
    $lcma = List::Compare-&gt;new('-a', 
                \@Al, \@Bob, \@Carmen, \@Don, \@Ed);</pre>
<p>As with List::Compare's other cases, should you not need to have 
a sorted list returned by a List::Compare method, you may achieve a 
speed boost by constructing the object with the unsorted option:</p>
<pre>
    $lcma = List::Compare-&gt;new('-u', '-a', 
                \@Al, \@Bob, \@Carmen, \@Don, \@Ed);</pre>
<p>or</p>
<pre>
    $lcma = List::Compare-&gt;new('--unsorted', '--accelerated',
                \@Al, \@Bob, \@Carmen, \@Don, \@Ed);</pre>
<p>As was the case with List::Compare's Multiple mode, do not count the 
unsorted option (<code>'-u'</code> or <code>'--unsorted'</code>) or the accelerated option 
(<code>'-a'</code> or <code>'--accelerated'</code>) when determining the index position of 
a particular list in the list of array references passed to the constructor.</p>
<p>Example:</p>
<pre>
    $lcmaex = List::Compare-&gt;new('--unsorted', '--accelerated',
                   \@alpha, \@beta, \@gamma);</pre>
<p></p>
<li><strong>Alternative Constructor</strong><br />
</li>
The 'single hashref' format may be used to construct a List::Compare 
object which calls for accelerated processing of three or more lists at once:
<pre>
    $lcmaex = List::Compare-&gt;new( {
        accelerated =&gt; 1,
        lists       =&gt; [\@alpha, \@beta, \@gamma],
    } );</pre>
<p>or</p>
<pre>
    $lcmaex = List::Compare-&gt;new( {
        unsorted    =&gt; 1,
        accelerated =&gt; 1,
        lists       =&gt; [\@alpha, \@beta, \@gamma],
    } );</pre>
<p></p>
<li><strong>Methods</strong><br />
</li>
For the purpose of supplying a numerical argument to a method which 
optionally takes such an argument, <code>'--unsorted'</code> and <code>'--accelerated</code> 
are skipped, <code>@alpha</code> is <code>0</code>, <code>@beta</code> is <code>1</code>, and so forth.  To get a 
list of those items unique to <code>@gamma</code>, you would call:
<pre>
    @gamma_only = $lcmaex-&gt;get_unique(2);</pre>
<p></p></ul>
<p>
</p>
<h2><a name="passing_seenhashes_to_the_constructor_instead_of_arrays">Passing Seen-hashes to the Constructor Instead of Arrays</a></h2>
<ul>
<li><strong><a name="item_when_seen_2dhashes_are_already_available_to_you">When Seen-Hashes Are Already Available to You</a></strong><br />
</li>
Suppose that in a particular Perl program, you had to do extensive munging of 
data from an external source and that, once you had correctly parsed a line 
of data, it was easier to assign that datum to a hash than to an array.  
More specifically, suppose that you used each datum as the key to an element 
of a lookup table in the form of a <em>seen-hash</em>:
<pre>
   my %Llist = (
       abel     =&gt; 2,
       baker    =&gt; 1,
       camera   =&gt; 1,
       delta    =&gt; 1,
       edward   =&gt; 1,
       fargo    =&gt; 1,
       golfer   =&gt; 1,
   );</pre>
<pre>
   my %Rlist = (
       baker    =&gt; 1,
       camera   =&gt; 1,
       delta    =&gt; 2,
       edward   =&gt; 1,
       fargo    =&gt; 1,
       golfer   =&gt; 1,
       hilton   =&gt; 1,
   );</pre>
<p>In other words, suppose it was more convenient to compute a lookup table 
<em>implying</em> a list than to compute that list explicitly.</p>
<p>Since in almost all cases List::Compare takes the elements in the arrays 
passed to its constructor and <em>internally</em> assigns them to elements in a 
seen-hash, why shouldn't you be able to pass (references to) seen-hashes 
<em>directly</em> to the constructor and avoid unnecessary array 
assignments before the constructor is called?</p>
<p></p>
<li><strong>Constructor</strong><br />
</li>
You can now do so:
<pre>
    $lcsh = List::Compare-&gt;new(\%Llist, \%Rlist);</pre>
<p></p>
<li><strong>Methods</strong><br />
</li>
<em>All</em> of List::Compare's output methods are supported <em>without further 
modification</em> when references to seen-hashes are passed to the constructor.
<pre>
    @intersection         = $lcsh-&gt;get_intersection;
    @union                = $lcsh-&gt;get_union;
    @Lonly                = $lcsh-&gt;get_unique;
    @Ronly                = $lcsh-&gt;get_complement;
    @LorRonly             = $lcsh-&gt;get_symmetric_difference;
    @bag                  = $lcsh-&gt;get_bag;
    $intersection_ref     = $lcsh-&gt;get_intersection_ref;
    $union_ref            = $lcsh-&gt;get_union_ref;
    $Lonly_ref            = $lcsh-&gt;get_unique_ref;
    $Ronly_ref            = $lcsh-&gt;get_complement_ref;
    $LorRonly_ref         = $lcsh-&gt;get_symmetric_difference_ref;
    $bag_ref              = $lcsh-&gt;get_bag_ref;
    $LR                   = $lcsh-&gt;is_LsubsetR;
    $RL                   = $lcsh-&gt;is_RsubsetL;
    $eqv                  = $lcsh-&gt;is_LequivalentR;
    $disj                 = $lcsh-&gt;is_LdisjointR;
                            $lcsh-&gt;print_subset_chart;
                            $lcsh-&gt;print_equivalence_chart;
    @memb_arr             = $lsch-&gt;is_member_which('abel');
    $memb_arr_ref         = $lsch-&gt;is_member_which_ref('baker');
    $memb_hash_ref        = $lsch-&gt;are_members_which(
                                [ qw| abel baker fargo hilton zebra | ]);
    $found                = $lsch-&gt;is_member_any('abel');
    $memb_hash_ref        = $lsch-&gt;are_members_any(
                                [ qw| abel baker fargo hilton zebra | ]);
    $vers                 = $lcsh-&gt;get_version;
    $unique_all_ref       = $lcsh-&gt;get_unique_all();
    $complement_all_ref   = $lcsh-&gt;get_complement_all();</pre>
<p></p>
<li><strong><a name="item_accelerated_mode_and_seen_2dhashes">Accelerated Mode and Seen-Hashes</a></strong><br />
</li>
To accelerate processing when you want only a single comparison among two or 
more lists, you can pass <code>'-a'</code> or <code>'--accelerated</code> to the constructor 
before passing references to seen-hashes.
<pre>
    $lcsha = List::Compare-&gt;new('-a', \%Llist, \%Rlist);</pre>
<p>To compare three or more lists simultaneously, pass three or more references 
to seen-hashes.  Thus,</p>
<pre>
    $lcshm = List::Compare-&gt;new(\%Alpha, \%Beta, \%Gamma);</pre>
<p>will generate meaningful comparisons of three or more lists simultaneously.</p>
<p></p>
<li><strong><a name="item_unsorted_results_and_seen_2dhashes">Unsorted Results and Seen-Hashes</a></strong><br />
</li>
If you do not need sorted lists returned, pass <code>'-u'</code> or <code>--unsorted</code> to the 
constructor before passing references to seen-hashes.
<pre>
    $lcshu  = List::Compare-&gt;new('-u', \%Llist, \%Rlist);
    $lcshau = List::Compare-&gt;new('-u', '-a', \%Llist, \%Rlist);
    $lcshmu = List::Compare-&gt;new('--unsorted', \%Alpha, \%Beta, \%Gamma);</pre>
<p>As was true when we were using List::Compare's Multiple and Multiple Accelerated 
modes, do not count any unsorted or accelerated option when determining the 
array index of a particular seen-hash reference passed to the constructor.</p>
<p></p>
<li><strong>Alternative Constructor</strong><br />
</li>
The 'single hashref' form of constructor is also available to build 
List::Compare objects where seen-hashes are used as arguments:
<pre>
    $lcshu  = List::Compare-&gt;new( {
        unsorted =&gt; 1,
        lists    =&gt; [\%Llist, \%Rlist],
    } );</pre>
<pre>
    $lcshau = List::Compare-&gt;new( {
        unsorted    =&gt; 1,
        accelerated =&gt; 1,
        lists       =&gt; [\%Llist, \%Rlist],
    } );</pre>
<pre>
    $lcshmu = List::Compare-&gt;new( {
        unsorted =&gt; 1,
        lists    =&gt; [\%Alpha, \%Beta, \%Gamma],
    } );</pre>
<p></p></ul>
<p>
</p>
<hr />
<h1><a name="discussion__principles">DISCUSSION:  Principles</a></h1>
<p>
</p>
<h2><a name="general_comments">General Comments</a></h2>
<p>List::Compare is an object-oriented implementation of very common Perl 
code (see <a href="#history__references_and_development">History, References and Development</a> below) used to
determine interesting relationships between two or more lists at a time.  
A List::Compare object is created and automatically computes the values
needed to supply List::Compare methods with appropriate results.  In the
current implementation List::Compare methods will return new lists
containing the items found in any designated list alone (unique), any list 
other than a designated list (complement), the intersection and union of 
all lists and so forth.  List::Compare also has (a) methods to return Boolean
values indicating whether one list is a subset of another and whether any 
two lists are equivalent to each other (b) methods to pretty-print very 
simple charts displaying the subset and equivalence relationships among 
lists.</p>
<p>Except for List::Compare's <code>get_bag()</code> method, <strong>multiple instances of 
an element in a given list count only once with 
respect to computing the intersection, union, etc. of the two lists.</strong>  In 
particular, List::Compare considers two lists as equivalent if each element 
of the first list can be found in the second list and <em>vice versa</em>.  
'Equivalence' in this usage takes no note of the frequency with which 
elements occur in either list or their order within the lists.  List::Compare 
asks the question:  <em>Did I see this item in this list at all?</em>  Only when 
you use <code>List::Compare::get_bag()</code> to compute a bag holding the two lists do you 
ask the question:  How many times did this item occur in this list?</p>
<p>
</p>
<h2><a name="list__compare_modes">List::Compare Modes</a></h2>
<p>In its current implementation List::Compare has four modes of operation.</p>
<ul>
<li></li>
Regular Mode
<p>List::Compare's Regular mode is based on List::Compare v0.11 -- the first 
version of List::Compare released to CPAN (June 2002).  It compares only 
two lists at a time.  Internally, its initializer does all computations 
needed to report any desired comparison and its constructor stores the 
results of these computations.  Its public methods merely report these 
results.</p>
<p>This approach has the advantage that if you need to examine more 
than one form of comparison between two lists (<em>e.g.,</em> the union, 
intersection and symmetric difference of two lists), the comparisons are 
pre-calculated.  This approach is efficient because certain types of 
comparison presuppose that other types have already been calculated.  
For example, to calculate the symmetric difference of two lists, one must 
first determine the items unique to each of the two lists.</p>
<p></p>
<li></li>
Accelerated Mode
<p>The current implementation of List::Compare offers you the option of 
getting even faster results <em>provided</em> that you only need the 
result from a <em>single</em> form of comparison between two lists. (<em>e.g.,</em> only 
the union -- nothing else).  In the Accelerated mode, List::Compare's 
initializer does no computation and its constructor stores only references 
to the two source lists.  All computation needed to report results is 
deferred to the method calls.</p>
<p>The user selects this approach by passing the option flag <code>'-a'</code> to the 
constructor before passing references to the two source lists.  
List::Compare notes the option flag and silently switches into Accelerated 
mode.  From the perspective of the user, there is no further difference in 
the code or in the results.</p>
<p>Benchmarking suggests that List::Compare's Accelerated mode (a) is faster 
than its Regular mode when only one comparison is requested; (b) is about as 
fast as Regular mode when two comparisons are requested; and (c) becomes 
considerably slower than Regular mode as each additional comparison above two 
is requested.</p>
<p></p>
<li></li>
Multiple Mode
<p>List::Compare now offers the possibility of comparing three or more lists at 
a time.  Simply store the extra lists in arrays and pass references to those 
arrays to the constructor.  List::Compare detects that more than two lists 
have been passed to the constructor and silently switches into Multiple mode.</p>
<p>As described in the Synopsis above, comparing more than two lists at a time 
offers you a wider, more complex palette of comparison methods.  
Individual items may appear in just one source list, in all the source lists, 
or in some number of lists between one and all.  The meaning of 'union', 
'intersection' and 'symmetric difference' is conceptually unchanged 
when you move to multiple lists because these are properties of all the lists 
considered together.  In contrast, the meaning of 'unique', 'complement', 
'subset' and 'equivalent' changes because these are properties of one list 
compared with another or with all the other lists combined.</p>
<p>List::Compare takes this complexity into account by allowing you to pass 
arguments to the public methods requesting results with respect to a specific 
list (for <code>get_unique()</code> and <code>get_complement()</code>) or a specific pair of lists 
(for <code>is_LsubsetR()</code> and <code>is_LequivalentR()</code>).</p>
<p>List::Compare further takes this complexity into account by offering the 
new methods <code>get_shared()</code> and <code>get_nonintersection()</code> described in the 
Synopsis above.</p>
<p></p>
<li></li>
Multiple Accelerated Mode
<p>Beginning with version 0.25, introduced in April 2004, List::Compare 
offers the possibility of accelerated computation of a single comparison 
among three or more lists at a time.  Simply store the extra lists in 
arrays and pass references to those arrays to the constructor preceded by 
the <code>'-a'</code> argument as was done with the simple (two lists only) 
accelerated mode.  List::Compare detects that more than two lists have been 
passed to the constructor and silently switches into Multiple Accelerated 
mode.</p>
<p></p>
<li></li>
Unsorted Option
<p>When List::Compare is used to return lists representing various comparisons 
of two or more lists (<em>e.g.</em>, the lists' union or intersection), the lists 
returned are, by default, sorted using Perl's default <code>sort</code> mode:  
ASCII-betical sorting.  Sorting produces results which are more easily 
human-readable but may entail a performance cost.</p>
<p>Should you not need sorted results, you can avoid the potential 
performance cost by calling List::Compare's constructor using the unsorted 
option.  This is done by calling <code>'-u'</code> or <code>'--unsorted'</code> as the first 
argument passed to the constructor, <em>i.e.</em>, as an argument called before 
any references to lists are passed to the constructor.</p>
<p>Note that if are calling List::Compare in the Accelerated or Multiple 
Accelerated mode <em>and</em> wish to have the lists returned in unsorted order, 
you <em>first</em> pass the argument for the unsorted option 
(<code>'-u'</code> or <code>'--unsorted'</code>) and <em>then</em> pass the argument for the 
Accelerated mode (<code>'-a'</code> or <code>'--accelerated'</code>).</p>
<p></p></ul>
<p>
</p>
<h2><a name="miscellaneous_methods">Miscellaneous Methods</a></h2>
<p>It would not really be appropriate to call <code>get_shared()</code> and 
<code>get_nonintersection()</code> in Regular or Accelerated mode since they are 
conceptually based on the notion of comparing more than two lists at a time.  
However, there is always the possibility that a user may be comparing only two 
lists (accelerated or not) and may accidentally call one of those two methods.  
To prevent fatal run-time errors and to caution you to use a more 
appropriate method, these two methods are defined for Regular and Accelerated 
modes so as to return suitable results but also generate a carp message that 
advise you to re-code.</p>
<p>Similarly, the method <code>is_RsubsetL()</code> is appropriate for the Regular and 
Accelerated modes but is not really appropriate for Multiple mode.  As a 
defensive maneuver, it has been defined for Multiple mode so as to return 
suitable results but also to generate a carp message that advises you to 
re-code.</p>
<p>In List::Compare v0.11 and earlier, the author provided aliases for various 
methods based on the supposition that the source lists would be referred to as 
'A' and 'B'.  Now that you can compare more than two lists at a time, the author 
feels that it would be more appropriate to refer to the elements of two-argument 
lists as the left-hand and right-hand elements.  Hence, we are discouraging the 
use of methods such as <code>get_Aonly()</code>, <code>get_Bonly()</code> and <code>get_AorBonly()</code> as 
aliases for <code>get_unique()</code>, <code>get_complement()</code> and 
<code>get_symmetric_difference()</code>.  However, to guarantee backwards compatibility 
for the vast audience of Perl programmers using earlier versions of 
List::Compare (all 10e1 of you) these and similar methods for subset 
relationships are still defined.</p>
<p>
</p>
<h2><a name="list__compare__seenhash_discontinued_beginning_with_version_0_26">List::Compare::SeenHash Discontinued Beginning with Version 0.26</a></h2>
<p>Prior to v0.26, introduced April 11, 2004, if a user wished to pass 
references to seen-hashes to List::Compare's constructor rather than 
references to arrays, he or she had to call a different, parallel module:  
List::Compare::SeenHash.  The code for that looked like this:</p>
<pre>
    use List::Compare::SeenHash;</pre>
<pre>
    my %Llist = (
       abel     =&gt; 2,
       baker    =&gt; 1,
       camera   =&gt; 1,
       delta    =&gt; 1,
       edward   =&gt; 1,
       fargo    =&gt; 1,
       golfer   =&gt; 1,
    );</pre>
<pre>
    my %Rlist = (
       baker    =&gt; 1,
       camera   =&gt; 1,
       delta    =&gt; 2,
       edward   =&gt; 1,
       fargo    =&gt; 1,
       golfer   =&gt; 1,
       hilton   =&gt; 1,
    );</pre>
<pre>
    my $lcsh = List::Compare::SeenHash-&gt;new(\%Llist, \%Rlist);</pre>
<p><strong>List::Compare::SeenHash is deprecated beginning with version 0.26.</strong>  All 
its functionality (and more) has been implemented in List::Compare itself, 
since a user can now pass <em>either</em> a series of array references <em>or</em> a 
series of seen-hash references to List::Compare's constructor.</p>
<p>To simplify future maintenance of List::Compare, List::Compare::SeenHash.pm 
will no longer be distributed with List::Compare, nor will the files in the 
test suite which tested List::Compare::SeenHash upon installation be distributed.</p>
<p>Should you still need List::Compare::SeenHash, use version 0.25 from CPAN, or 
simply edit your Perl programs which used List::Compare::SeenHash.  Those 
scripts may be edited quickly with, for example, this editing command in 
Unix text editor <em>vi</em>:</p>
<pre>
    :1,$s/List::Compare::SeenHash/List::Compare/gc</pre>
<p>
</p>
<h2><a name="a_nonobjectoriented_interface__list__compare__functional">A Non-Object-Oriented Interface:  List::Compare::Functional</a></h2>
<p>Version 0.21 of List::Compare introduced List::Compare::Functional, 
a functional (<em>i.e.</em>, non-object-oriented) interface to list comparison 
functions.  List::Compare::Functional supports the same functions currently 
supported by List::Compare.  It works similar to List::Compare's Accelerated 
and Multiple Accelerated modes (described above), bit it does not 
require use of the <code>'-a'</code> flag in the function call.  
List::Compare::Functional will return unsorted comparisons of two lists by 
passing <code>'-u'</code> or <code>'--unsorted'</code> as the first argument to the function.  
Please see the documentation for List::Compare::Functional to learn how to 
import its functions into your main package.</p>
<p>
</p>
<hr />
<h1><a name="assumptions_and_qualifications">ASSUMPTIONS AND QUALIFICATIONS</a></h1>
<p>The program was created with Perl 5.6. The use of <em>h2xs</em> to prepare 
the module's template installed <code>require 5.005_62;</code> at the top of the
module.  This has been commented out in the actual module as the code 
appears to be compatible with earlier versions of Perl; how earlier the 
author cannot say.  In particular, the author would like the module to 
be installable on older versions of MacPerl.  As is, the author has 
successfully installed the module on Linux, Windows 9x and Windows 2000.  
See <a href="http://testers.cpan.org/show/List-Compare.html">http://testers.cpan.org/show/List-Compare.html</a> for 
a list of other systems on which this version of List::Compare has been 
tested and installed.</p>
<p>
</p>
<hr />
<h1><a name="history__references_and_development">HISTORY, REFERENCES AND DEVELOPMENT</a></h1>
<p>
</p>
<h2><a name="the_code_itself">The Code Itself</a></h2>
<p>List::Compare is based on code presented by Tom Christiansen &amp; Nathan
Torkington in <em>Perl Cookbook</em> <a href="http://www.oreilly.com/catalog/cookbook/">http://www.oreilly.com/catalog/cookbook/</a>
(a.k.a. the 'Ram' book), O'Reilly &amp; Associates, 1998, Recipes 4.7 and 4.8. 
Similar code is presented in the Camel book:  <em>Programming Perl</em>, by Larry
Wall, Tom Christiansen, Jon Orwant. 
<a href="http://www.oreilly.com/catalog/pperl3/">http://www.oreilly.com/catalog/pperl3/</a>, 3rd ed, O'Reilly &amp; Associates,
2000.  The list comparison code is so basic and Perlish that I suspect it
may have been written by Larry himself at the dawn of Perl time.  The 
<code>get_bag()</code> method was inspired by Jarkko Hietaniemi's Set::Bag module
and Daniel Berger's Set::Array module, both available on CPAN.</p>
<p>List::Compare's original objective was simply to put this code in a modular, 
object-oriented framework.  That framework, not surprisingly, is taken mostly 
from Damian Conway's <em>Object Oriented Perl</em> 
<a href="http://www.manning.com/Conway/index.html">http://www.manning.com/Conway/index.html</a>, Manning Publications, 2000.</p>
<p>With the addition of the Accelerated, Multiple and Multiple Accelerated 
modes, List::Compare expands considerably in both size and capabilities.  
Nonetheless,  Tom and Nat's <em>Cookbook</em> code still lies at its core:  
the use of hashes as look-up tables to record elements seen in lists.  
Please note:  List::Compare is not concerned with any concept of 'equality' 
among lists which hinges upon the frequency with which, or the order in 
which, elements appear in the lists to be compared.  If this does not 
meet your needs, you should look elsewhere or write your own module.</p>
<p>
</p>
<h2><a name="the_inspiration">The Inspiration</a></h2>
<p>I realized the usefulness of putting the list comparison code into a
module while preparing an introductory level Perl course given at the New
School University's Computer Instruction Center in April-May 2002.  I was
comparing lists left and right.  When I found myself writing very similar
functions in different scripts, I knew a module was lurking somewhere. 
I learned the truth of the mantra ''Repeated Code is a Mistake'' from a 
2001 talk by Mark-Jason Dominus <a href="http://perl.plover.com/">http://perl.plover.com/</a> to the New York 
Perlmongers <a href="http://ny.pm.org/">http://ny.pm.org/</a>.  
See <a href="http://www.perl.com/pub/a/2000/11/repair3.html">http://www.perl.com/pub/a/2000/11/repair3.html</a>.</p>
<p>The first public presentation of this module took place at Perl Seminar 
New York <a href="http://groups.yahoo.com/group/perlsemny">http://groups.yahoo.com/group/perlsemny</a> on May 21, 2002.  
Comments and suggestions were provided there and since by Glenn Maciag, 
Gary Benson, Josh Rabinowitz, Terrence Brannon and Dave Cross.</p>
<p>The placement in the installation tree of Test::ListCompareSpecial came 
as a result of a question answered by Michael Graham in his talk 
''Test::More to Test::Extreme'' given at Yet Another Perl Conference::Canada 
in Ottawa, Ontario, on May 16, 2003.</p>
<p>In May-June 2003, Glenn Maciag made valuable suggestions which led to 
changes in method names and documentation in v0.20.</p>
<p>Another presentation at Perl Seminar New York in 
October 2003 prompted me to begin planning List::Compare::Functional.</p>
<p>In a November 2003 Perl Seminar New York presentation, Ben Holtzman 
discussed the performance costs entailed in Perl's <code>sort</code> function.  
This led me to ask, ''Why should a user of List::Compare pay this performance 
cost if he or she doesn't need a human-readable list as a result (as 
would be the case if the list returned were used as the input into some 
other function)?''  This led to the development of List::Compare's 
unsorted option.</p>
<p>An April 2004 offer by Kevin Carlson to write an article for <em>The Perl Journal</em> 
(<a href="http://tpj.com">http://tpj.com</a>) led me to re-think whether a separate module 
(the former List::Compare::SeenHash) was truly needed when a user wanted 
to provide the constructor with references to seen-hashes rather than 
references to arrays.  Since I had already adapted List::Compare::Functional 
to accept both kinds of arguments, I adapted List::Compare in the same 
manner.  This meant that List::Compare::SeenHash and its related installation 
tests could be deprecated and deleted from the CPAN distribution.</p>
<p>A remark by David H. Adler at a New York Perlmongers meeting in April 2004 
led me to develop the 'single hashref' alternative constructor format, 
introduced in version 0.29 the following month.</p>
<p>Presentations at two different editions of Yet Another Perl Conference (YAPC) 
inspired the development of List::Compare versions 0.30 and 0.31.  I was 
selected to give a talk on List::Compare at YAPC::NA::2004 in Buffalo.  This 
spurred me to improve certain aspects of the documentation.  Version 0.31 
owes its inspiration to one talk at the Buffalo YAPC and one earlier talk at 
YAPC::EU::2003 in Paris.  In Paris I heard Paul Johnson speak on his CPAN 
module Devel::Cover and on coverage analysis more generally.  That material 
was over my head at that time, but in Buffalo I heard Andy Lester discuss 
Devel::Cover as part of his discussion of testing and of the Phalanx project 
(<a href="http://qa.perl.org/phalanx">http://qa.perl.org/phalanx</a>).  This time I got it, and when I returned 
from Buffalo I applied Devel::Cover to List::Compare and wrote additional tests 
to improve its subroutine and statement coverage.  In addition, I added two 
new methods, <code>get_unique_all</code> and <code>get_complement_all</code>.  In writing these 
two methods, I followed a model of test-driven development much more so than 
in earlier versions of List::Compare and my other CPAN modules.  The result?  
List::Compare's test suite grew by over 3300 tests to nearly 23,000 tests.</p>
<p>
</p>
<h2><a name="if_you_like_list__compare__you_ll_love____">If You Like List::Compare, You'll Love ...</a></h2>
<p>While preparing this module for distribution via CPAN, I had occasion to
study a number of other modules already available on CPAN.  Each of these
modules is more sophisticated than List::Compare -- which is not surprising
since all that List::Compare originally aspired to do was to avoid typing
Cookbook code repeatedly.  Here is a brief description of the features of
these modules.  (<strong>Warning:</strong>  The following discussion is only valid as 
of June 2002.  Some of these modules may have changed since then.)</p>
<ul>
<li></li>
Algorithm::Diff - Compute 'intelligent' differences between two files/lists
(<a href="http://search.cpan.org/author/NEDKONZ/Algorithm-Diff-1.15/lib/Algorithm/Diff.pm">http://search.cpan.org/author/NEDKONZ/Algorithm-Diff-1.15/lib/Algorithm/Diff.pm</a>)
<p>Algorithm::Diff is a sophisticated module originally written by Mark-Jason
Dominus and now maintained by Ned Konz. Think of the Unix <code>diff</code> utility 
and you're on the right track.  Algorithm::Diff exports methods such as 
<code>diff</code>, which ''computes the smallest set of additions and deletions necessary 
to turn the first sequence into the second, and returns a description of these
changes.''  Algorithm::Diff is mainly concerned with the sequence of
elements within two lists.  It does not export functions for intersection,
union, subset status, etc.</p>
<p></p>
<li></li>
Array::Compare - Perl extension for comparing arrays
(<a href="http://search.cpan.org/author/DAVECROSS/Array-Compare-1.03/Compare.pm">http://search.cpan.org/author/DAVECROSS/Array-Compare-1.03/Compare.pm</a>)
<p>Array::Compare, by Dave Cross, asks whether two arrays
are the same or different by doing a <code>join</code> on each string with a
separator character and comparing the resulting strings.  Like
List::Compare, it is an object-oriented module.  A sophisticated feature of
Array::Compare is that it allows you to specify how 'whitespace' in an
array (an element which is undefined, the empty string, or whitespace
within an element) should be evaluated for purpose of determining equality
or difference.    It does not directly provide methods for intersection and
union.</p>
<p></p>
<li></li>
List::Util - A selection of general-utility list subroutines
(<a href="http://search.cpan.org/author/GBARR/Scalar-List-Utils-1.0701/lib/List/Util.pm">http://search.cpan.org/author/GBARR/Scalar-List-Utils-1.0701/lib/List/Util.pm</a>)
<p>List::Util, by Graham Barr, exports a variety of simple,
useful functions for operating on one list at a time.    The <code>min</code> function
returns the lowest numerical value in a list; the <code>max</code> function returns
the highest value; and so forth.  List::Compare differs from List::Util in
that it is object-oriented and that it works on two strings at a time
rather than just one -- but it aims to be as simple and useful as
List::Util.  List::Util will be included in the standard Perl 
distribution as of Perl 5.8.0.</p>
<p>Lists::Util (<a href="http://search.cpan.org/author/TBONE/List-Utils-0.01/Utils.pm">http://search.cpan.org/author/TBONE/List-Utils-0.01/Utils.pm</a>), 
by Terrence Brannon, provides methods which extend List::Util's functionality.</p>
<p></p>
<li></li>
Quantum::Superpositions 
(<a href="http://search.cpan.org/author/DCONWAY/Quantum-Superpositions-1.03/lib/Quantum/Superpositions.pm">http://search.cpan.org/author/DCONWAY/Quantum-Superpositions-1.03/lib/Quantum/Superpositions.pm</a>), 
by Damian Conway, is useful if, in addition to comparing lists, you need to
emulate quantum supercomputing as well.  Not for the eigen-challenged.
<p></p>
<li></li>
Set::Scalar - basic set operations
(<a href="http://search.cpan.org/author/JHI/Set-Scalar-1.17/lib/Set/Scalar.pm">http://search.cpan.org/author/JHI/Set-Scalar-1.17/lib/Set/Scalar.pm</a>)
<p>Set::Bag - bag (multiset) class
(<a href="http://search.cpan.org/author/JHI/Set-Bag-1.007/Bag.pm">http://search.cpan.org/author/JHI/Set-Bag-1.007/Bag.pm</a>)</p>
<p>Both of these modules are by Jarkko Hietaniemi.  Set::Scalar
has methods to return the intersection, union, difference and symmetric
difference of two sets, as well as methods to return items unique to a
first set and complementary to it in a second set.  It has methods for
reporting considerably more variants on subset status than does
List::Compare.  However, benchmarking suggests that List::Compare, at 
least in Regular mode, is considerably faster than Set::Scalar for those 
comparison methods which List::Compare makes available.</p>
<p>Set::Bag enables one to deal more flexibly with the situation in which one
has more than one instance of an element in a list.</p>
<p></p>
<li></li>
Set::Array - Arrays as objects with lots of handy methods (including set
comparisons) and support for method chaining.
(<a href="http://search.cpan.org/author/DJBERG/Set-Array-0.08/Array.pm">http://search.cpan.org/author/DJBERG/Set-Array-0.08/Array.pm</a>)
<p>Set::Array, by Daniel Berger, ''aims to provide
built-in methods for operations that people are always asking how to do,and
which already exist in languages like Ruby.''  Among the many methods in
this module are some for intersection, union, etc.  To install Set::Array,
you must first install the Want module, also available on CPAN.</p>
<p></p></ul>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>James E. Keenan (<a href="mailto:jkeenan@cpan.org">jkeenan@cpan.org</a>)  When sending correspondence, please 
include 'List::Compare' or 'List-Compare' in your subject line.</p>
<p>Creation date:  May 20, 2002.  Last modification date:  August 15, 2004. 
Copyright (c) 2002-04 James E. Keenan.  United States.  All rights reserved. 
This is free software and may be distributed under the same terms as Perl
itself.</p>

</body>

</html>
